using UnityEngine;
using UnityEditor;
using System.IO;
using System.Text;
using System.Collections.Generic;
using System.Linq;

public class YamlToStringProcessor : AssetPostprocessor
{
    private const string YAML_FOLDER = "Assets/DialogueData";
    private const string OUTPUT_FOLDER = "Assets/Scripts/Generated";
    private const string OUTPUT_CLASS = "EmbeddedDialogues";
    private const string NAMESPACE = "DialogueSystem";
    
    // This runs automatically when assets are imported/modified
    static void OnPostprocessAllAssets(string[] importedAssets, string[] deletedAssets, string[] movedAssets, string[] movedFromAssetPaths)
    {
        bool yamlFilesChanged = false;
        
        // Check if any YAML files were modified
        foreach (string assetPath in importedAssets)
        {
            if (IsYamlFile(assetPath) && assetPath.StartsWith(YAML_FOLDER))
            {
                yamlFilesChanged = true;
                break;
            }
        }
        
        // Check if any YAML files were deleted
        foreach (string assetPath in deletedAssets)
        {
            if (IsYamlFile(assetPath) && assetPath.StartsWith(YAML_FOLDER))
            {
                yamlFilesChanged = true;
                break;
            }
        }
        
        if (yamlFilesChanged)
        {
            GenerateEmbeddedDialogues();
        }
    }
    
    private static bool IsYamlFile(string path)
    {
        string extension = Path.GetExtension(path).ToLower();
        return extension == ".yaml" || extension == ".yml";
    }
    
    [MenuItem("Tools/Regenerate Embedded Dialogues")]
    public static void RegenerateDialogues()
    {
        GenerateEmbeddedDialogues();
    }
    
    private static void GenerateEmbeddedDialogues()
    {
        // Create output directory if it doesn't exist
        if (!Directory.Exists(OUTPUT_FOLDER))
        {
            Directory.CreateDirectory(OUTPUT_FOLDER);
        }
        
        // Find all YAML files
        var yamlFiles = new List<string>();
        if (Directory.Exists(YAML_FOLDER))
        {
            yamlFiles.AddRange(Directory.GetFiles(YAML_FOLDER, "*.yaml", SearchOption.AllDirectories));
            yamlFiles.AddRange(Directory.GetFiles(YAML_FOLDER, "*.yml", SearchOption.AllDirectories));
        }
        
        // Generate C# file
        string outputPath = Path.Combine(OUTPUT_FOLDER, $"{OUTPUT_CLASS}.cs");
        GenerateCSharpFile(yamlFiles, outputPath);
        
        // Refresh asset database
        AssetDatabase.Refresh();
        
        Debug.Log($"Generated {OUTPUT_CLASS}.cs with {yamlFiles.Count} YAML files embedded as strings.");
    }
    
    private static void GenerateCSharpFile(List<string> yamlFiles, string outputPath)
    {
        var sb = new StringBuilder();
        
        // File header
        sb.AppendLine("// AUTO-GENERATED CODE - DO NOT EDIT MANUALLY!");
        sb.AppendLine("// This file is automatically generated from YAML files in DialogueData folder");
        sb.AppendLine("// Regenerated whenever YAML files are modified");
        sb.AppendLine();
        sb.AppendLine("using System.Collections.Generic;");
        sb.AppendLine("using System.Linq;");
        sb.AppendLine();
        sb.AppendLine($"namespace {NAMESPACE}");
        sb.AppendLine("{");
        sb.AppendLine($"    public static class {OUTPUT_CLASS}");
        sb.AppendLine("    {");
        
        // Generate string constants for each file
        foreach (string filePath in yamlFiles)
        {
            string fileName = Path.GetFileNameWithoutExtension(filePath);
            string constantName = ToValidCSharpIdentifier(fileName);
            string yamlContent = File.ReadAllText(filePath);
            string escapedContent = EscapeStringLiteral(yamlContent);
            // string escapedContent = yamlContent;
            
            sb.AppendLine($"        public const string {constantName} = \"{escapedContent}\";");
            sb.AppendLine();
        }
        
        // Generate dictionary for runtime access
        sb.AppendLine("        private static readonly Dictionary<string, string> _dialogues = new Dictionary<string, string>");
        sb.AppendLine("        {");
        
        for (int i = 0; i < yamlFiles.Count; i++)
        {
            string fileName = Path.GetFileNameWithoutExtension(yamlFiles[i]);
            string constantName = ToValidCSharpIdentifier(fileName);
            
            sb.Append($"            [\"{fileName}\"] = {constantName}");
            if (i < yamlFiles.Count - 1)
                sb.Append(",");
            sb.AppendLine();
        }
        
        sb.AppendLine("        };");
        sb.AppendLine();
        
        // Helper methods
        sb.AppendLine("        public static string GetDialogue(string name)");
        sb.AppendLine("        {");
        sb.AppendLine("            return _dialogues.TryGetValue(name, out string dialogue) ? dialogue : null;");
        sb.AppendLine("        }");
        sb.AppendLine();
        sb.AppendLine("        public static bool HasDialogue(string name)");
        sb.AppendLine("        {");
        sb.AppendLine("            return _dialogues.ContainsKey(name);");
        sb.AppendLine("        }");
        sb.AppendLine();
        sb.AppendLine("        public static string[] GetAllDialogueNames()");
        sb.AppendLine("        {");
        sb.AppendLine("            return _dialogues.Keys.ToArray();");
        sb.AppendLine("        }");
        sb.AppendLine();
        sb.AppendLine("        public static Dictionary<string, string> GetAllDialogues()");
        sb.AppendLine("        {");
        sb.AppendLine("            return new Dictionary<string, string>(_dialogues);");
        sb.AppendLine("        }");
        
        // Close class and namespace
        sb.AppendLine("    }");
        sb.AppendLine("}");
        
        // Write file
        File.WriteAllText(outputPath, sb.ToString());
    }
    
    private static string ToValidCSharpIdentifier(string input)
    {
        if (string.IsNullOrEmpty(input))
            return "UNNAMED";
        
        // Replace invalid characters with underscores
        var sb = new StringBuilder();
        
        for (int i = 0; i < input.Length; i++)
        {
            char c = input[i];
            if (char.IsLetter(c) || c == '_' || (i > 0 && char.IsDigit(c)))
            {
                sb.Append(c);
            }
            else
            {
                sb.Append('_');
            }
        }
        
        string result = sb.ToString();
        
        // Ensure it starts with letter or underscore
        if (char.IsDigit(result[0]))
        {
            result = "_" + result;
        }
        
        // Convert to PascalCase
        return ToPascalCase(result);
    }
    
    private static string ToPascalCase(string input)
    {
        if (string.IsNullOrEmpty(input))
            return input;
        
        var parts = input.Split('_', '-', ' ');
        var sb = new StringBuilder();
        
        foreach (string part in parts)
        {
            if (!string.IsNullOrEmpty(part))
            {
                sb.Append(char.ToUpper(part[0]));
                if (part.Length > 1)
                    sb.Append(part.Substring(1).ToLower());
            }
        }
        
        return sb.ToString();
    }
    
    private static string EscapeStringLiteral(string input)
    {
        return input.Replace("\\", "\\\\")
                   .Replace("\"", "\\\"")
                   .Replace("\0", "\\0")
                   .Replace("\a", "\\a")
                   .Replace("\b", "\\b")
                   .Replace("\f", "\\f")
                   .Replace("\n", "\\n")
                   .Replace("\r", "\\r")
                   .Replace("\t", "\\t")
                   .Replace("\v", "\\v");
    }
}
